# 복잡한 타입 분석

## Promise, Awaited

#### Promise

Promise의 all 메서드는 다음과 같은 타입을 가진다.

```typescript
interface PromiseConstructor {
  //...

  all<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]> }>;

  //...
}
```

해석하자면, all의 파라미터로 들어온 promise 배열(튜플)을 각각 Awaited 타입처리하여 배열(튜플)로 반환한다.
그럼 `Awaited<T[P]>`는 무엇일까?

#### Awaited

조건은 다음과 같다.

1. T가 null | undefined 이면, T를 반환
2. T가 객체이고, then 메서드를 가진다면(Promise 객체를 의미), onfulfilled를 파라미터로 받을 때 그 타입을 F로 추론한다. (이 때, 만약 promise객체가 아니라면, T 타입 그래도 반환)
3. then으로 들어온 파라미터 F의 타입은 함수이어야 하고, F의 파라미터 value 타입을 V라고 했을 때, `Awaited<V>`를 반환한다.(재귀)
   - 왜냐하면, 그 다음 Promise 객체에서 동일한 과정으로 타입처리 해야하기 때문
4. 즉, Awaited처리 덕분에 Promise의 타입은 최종 재귀 반환 타입으로 결정됨

```typescript
type Awaited<T> =
  T extends null | undefined ? T :
    T extends object & { then(onfulfilled: infer F) => any } ?
      F extends ((value: infer V, ...args: any) => any) ?
        Awaited<V> :
        never :
    T
```

**참고**
Promise.then의 타입.

then은 promise가 성공했을 때, onfulfilled 함수 실행, 실패했을 때, onrejected 함수 실행.

```typescript
interface PromiseLike<T> {
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
  ): PromiseLike<TResult1 | TResult2>;
}
```

---

## bind() 메서드 분석

> func.bind(thisArg[, arg1[, arg2[, ...]]])
> 반환값 : 주어진 함수의 (this가 변경된) 복제본

thisArg를 해당 function의 this로 전달됨

1. **type ThisParameterType<T>**

```typescript
type ThisParameterType<T> = T extends (this: infer U, ...args: never) => any ? U : unknown;
```

함수 형태의 T를 받아 파라미터 this의 타입을 U로 추론
만약 추론이 되면, U 타입 반환
추론 실패 시, unknown

2. **type OmitThisParameter<T>**

```typescript
type OmitThisParameter<T> = unknown extends ThisParameterType<T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T;
```

- OmitThisParameter는 this를 사라지게 함

ThisParameterType<T>가 unknown이면, 즉 this의 타입추론이 실패했을 때, 받은 함수타입 그대로 T 반환
타입 추론 성공 시, 파라미터와 반환값의 타입을 추론하여 그대로 함수 타입 `(...args:A) => R` 타입 반환

3. **bind<T>**

```typescript
interface CallableFunction extends Function {
  //...
  bind<T>(this: T, thisArg: ThisParameterType<T>): OmitThisParameter<T>;
  bind<T, A0, A extends any[], R>(this: (this: T, arg0: A0, ...args: A) => R, thisArg: T, arg0: A0): (...args: A) => R;
  bind<T, A0, A1, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1): (...args: A) => R;
  bind<T, A0, A1, A2, A extends any[], R>(
    this: (this: T, arg0: A0, arg1: A1, arg2: A2, ...args: A) => R,
    thisArg: T,
    arg0: A0,
    arg1: A1,
    arg2: A2
  ): (...args: A) => R;
  bind<T, A0, A1, A2, A3, A extends any[], R>(
    this: (this: T, arg0: A0, arg1: A1, arg2: A2, arg3: A3, ...args: A) => R,
    thisArg: T,
    arg0: A0,
    arg1: A1,
    arg2: A2,
    arg3: A3
  ): (...args: A) => R;
  bind<T, AX, R>(this: (this: T, ...args: AX[]) => R, thisArg: T, ...args: AX[]): (...args: AX[]) => R;
  //...
}
```

bind를 사용하면, OmitThisParameter<T>로 인해 this가 없는 타입이 반환된다.

- bind를 통해 this를 결정하면, 반환된 복제 함수는 this가 고정이기 때문에 없애버림

bind의 this 외 매개변수가 입력될 경우 최대 4개까지 개별 타입 체크함
사실상 매개변수 많이 입력하는 경우가 거의 업음

---
